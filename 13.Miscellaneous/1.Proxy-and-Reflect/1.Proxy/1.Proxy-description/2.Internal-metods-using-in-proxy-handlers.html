<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!--
        Proxy is a special “exotic object”. It doesn’t have own properties. With an empty handler it 
        transparently forwards operations to target.

        To activate more capabilities, let’s add traps.

        What can we intercept with them?

        For most operations on objects, there’s a so-called “internal method” in the JavaScript specification that 
        describes how it works at the lowest level. For instance [[Get]], the internal method to read a property, 
        [[Set]], the internal method to write a property, and so on. These methods are only used in the specification, 
        we can’t call them directly by name.

        Proxy traps intercept invocations of these methods. They are listed in the Proxy specification and in the table 
        below.

        For every internal method, there’s a trap in this table: the name of the method that we can add to the handler 
        parameter of new Proxy to intercept the operation:

        Internal Method	            Handler Method	           Triggers when…
        [[Get]]	                    get	                       reading a property
        [[Set]]	                    set	                       writing to a property
        [[HasProperty]]	            has	                       in operator
        [[Delete]]	                deleteProperty	           delete operator
        [[Call]]	                apply	                   function call
        [[Construct]]	            construct	               new operator
        [[GetPrototypeOf]]	        getPrototypeOf	           Object.getPrototypeOf
        [[SetPrototypeOf]]	        setPrototypeOf	           Object.setPrototypeOf
        [[IsExtensible]]	        isExtensible	           Object.isExtensible
        [[PreventExtensions]]	    preventExtensions	       Object.preventExtensions
        [[DefineOwnProperty]]	    defineProperty	           Object.defineProperty, Object.defineProperties
        [[GetOwnProperty]]	        getOwnPropertyDescriptor   Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries
        [[OwnPropertyKeys]]	        ownKeys	                   Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries

        Invariants:
        JavaScript enforces some invariants – conditions that must be fulfilled by internal methods and traps.
        Most of them are for return values:
            1. [[Set]] must return true if the value was written successfully, otherwise false.
            2. [[Delete]] must return true if the value was deleted successfully, otherwise false.
            3. …and so on, we’ll see more in examples below.

        There are some other invariants, like:
            1. [[GetPrototypeOf]], applied to the proxy object must return the same value as [[GetPrototypeOf]] applied 
            to the proxy object’s target object. In other words, reading prototype of a proxy must always return the 
            prototype of the target object.

        Traps can intercept these operations, but they must follow these rules.

        Invariants ensure correct and consistent behavior of language features. The full invariants list is in the specification. 
        You probably won’t violate them if you’re not doing something weird.

    -->
</body>
</html>